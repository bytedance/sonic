//go:build arm64
// +build arm64

/*
 * Copyright 2025 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loader_test

import (
	"runtime"
	"runtime/debug"
	"strconv"
	"testing"
	"unsafe"

	. "github.com/bytedance/sonic/loader"
	"github.com/bytedance/sonic/loader/internal/rt"
	"github.com/stretchr/testify/require"
)

func TestLoadARM64(t *testing.T) {
	var hstr string

	type TestFunc func(i *int, hook func(i *int)) int
	var hook = func(i *int) {
		runtime.GC()
		debug.FreeOSMemory()
		hstr = ("hook" + strconv.Itoa(*i))
		runtime.GC()
		debug.FreeOSMemory()
	}

	// ARM64 bytecode generated by Go compiler for:
	// func(i *int, hook func(i *int)) int {
	//     var t = *i
	//     hook(i)
	//     return t + *i
	// }
	//
	// Stack layout (32 bytes frame):
	// sp+40: saved i pointer (arg area, outside frame)
	// sp+24: FP (frame pointer)
	// sp+16: saved old value of *i (local var)
	// sp+0:  return address (LR)
	bc := []byte{
		0xfe, 0x0f, 0x1e, 0xf8, // (0x00) MOVD.W R30, -32(RSP)  ; save LR and alloc stack
		0xfd, 0x83, 0x1f, 0xf8, // (0x04) MOVD R29, -8(RSP)     ; save FP
		0xfd, 0x23, 0x00, 0xd1, // (0x08) SUB $8, RSP, R29      ; set up FP
		0xe0, 0x17, 0x00, 0xf9, // (0x0c) MOVD R0, 40(RSP)      ; save i pointer (arg area)
		0x02, 0x00, 0x40, 0xf9, // (0x10) MOVD (R0), R2         ; R2 = *i
		0xe2, 0x0b, 0x00, 0xf9, // (0x14) MOVD R2, 16(RSP)      ; save old value
		0x23, 0x00, 0x40, 0xf9, // (0x18) MOVD (R1), R3         ; R3 = hook.fn
		0xfa, 0x03, 0x01, 0xaa, // (0x1c) MOVD R1, R26          ; save R1 to R26 (context)
		0x60, 0x00, 0x3f, 0xd6, // (0x20) CALL (R3)             ; call hook
		0xe1, 0x17, 0x40, 0xf9, // (0x24) MOVD 40(RSP), R1      ; restore i pointer
		0x21, 0x00, 0x40, 0xf9, // (0x28) MOVD (R1), R1         ; R1 = *i (new value)
		0xe2, 0x0b, 0x40, 0xf9, // (0x2c) MOVD 16(RSP), R2      ; restore old value
		0x40, 0x00, 0x01, 0x8b, // (0x30) ADD R1, R2, R0        ; R0 = old + new
		0xfd, 0xfb, 0x7f, 0xa9, // (0x34) LDP -8(RSP), (R29, R30) ; restore FP, LR
		0xff, 0x83, 0x00, 0x91, // (0x38) ADD $32, RSP, RSP     ; dealloc stack
		0xc0, 0x03, 0x5f, 0xd6, // (0x3c) RET                   ; return
	}

	size := uint32(len(bc))
	fn := Func{
		ID:          0,
		Flag:        0,
		ArgsSize:    16,
		EntryOff:    0,
		TextSize:    size,
		DeferReturn: 0,
		FileIndex:   0,
		Name:        "dummy_arm64",
	}

	fn.Pcsp = &Pcdata{
		{PC: size, Val: 32},
	}

	fn.Pcline = &Pcdata{
		{PC: 0x04, Val: 0},
		{PC: 0x0c, Val: 1},
		{PC: 0x24, Val: 2},
		{PC: size, Val: 3},
	}

	fn.Pcfile = &Pcdata{
		{PC: size, Val: 0},
	}

	fn.PcUnsafePoint = &Pcdata{
		{PC: size, Val: PCDATA_UnsafePointUnsafe},
	}

	fn.PcStackMapIndex = &Pcdata{
		{PC: size, Val: 0},
	}

	args := rt.StackMapBuilder{}
	args.AddField(true) // i *int
	args.AddField(true) // hook.fn
	fn.ArgsPointerMaps = args.Build()

	locals := rt.StackMapBuilder{}
	locals.AddField(false) // old value (int, non-pointer)
	locals.AddField(false) // padding/alignment
	fn.LocalsPointerMaps = locals.Build()

	rets := Load(bc, []Func{fn}, "dummy_arm64_module", []string{"github.com/bytedance/sonic/dummy_arm64.go"})
	println("func address ", *(*unsafe.Pointer)(rets[0]))

	f := *(*TestFunc)(unsafe.Pointer(&rets[0]))
	i := 1
	runtime.SetFinalizer(&i, func(x *int) {
		println("i got GC: ", x)
	})
	j := f(&i, hook)
	require.Equal(t, 2, j)
	require.Equal(t, "hook1", hstr)

	fi := runtime.FuncForPC(*(*uintptr)(rets[0]))
	require.Equal(t, "dummy_arm64", fi.Name())
	file, line := fi.FileLine(0)
	require.Equal(t, "github.com/bytedance/sonic/dummy_arm64.go", file)
	require.Equal(t, 0, line)
}

// TestWrapGoCAdd tests WrapGoC with a simple add function
func TestWrapGoCAdd(t *testing.T) {
	t.Log("Testing WrapGoC with add function: (a, b) -> a + b")

	// Simple add function: ADD x0, x0, x1; RET
	bytecode := []byte{
		0x00, 0x00, 0x01, 0x8b, // add x0, x0, x1
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	var addFunc func(int, int) int

	// Use WrapGoC to create the wrapper
	WrapGoC(bytecode, []CFunc{{
		Name:     "add",
		EntryOff: 0,
		TextSize: uint32(len(bytecode)),
		MaxStack: 0,
		Pcsp: [][2]uint32{
			{uint32(len(bytecode)), 0},
		},
	}}, []GoC{{
		CName:  "add",
		GoFunc: &addFunc,
	}}, "test_add", "add.c")

	// Test the wrapped function
	result := addFunc(15, 27)
	expected := 42

	if result != expected {
		t.Errorf("Add function failed: expected %d, got %d", expected, result)
	} else {
		t.Logf("✓ Add function works: %d + %d = %d", 15, 27, result)
	}
}

// TestWrapGoCConstant tests WrapGoC with a constant return function
func TestWrapGoCConstant(t *testing.T) {
	t.Log("Testing WrapGoC with constant function: () -> 42")

	// Constant function that returns 42
	bytecode := []byte{
		0x48, 0x05, 0x80, 0xd2, // mov x8, #42
		0xe0, 0x03, 0x08, 0xaa, // mov x0, x8
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	var constFunc func() int

	// Use WrapGoC to create the wrapper
	WrapGoC(bytecode, []CFunc{{
		Name:     "const42",
		EntryOff: 0,
		TextSize: uint32(len(bytecode)),
		MaxStack: 0,
		Pcsp: [][2]uint32{
			{uint32(len(bytecode)), 0},
		},
	}}, []GoC{{
		CName:  "const42",
		GoFunc: &constFunc,
	}}, "test_const", "const.c")

	// Test the wrapped function
	result := constFunc()
	expected := 42

	if result != expected {
		t.Errorf("Constant function failed: expected %d, got %d", expected, result)
	} else {
		t.Logf("✓ Constant function works: () -> %d", result)
	}
}

// TestWrapGoCMultiple tests WrapGoC with multiple parameters
func TestWrapGoCMultiple(t *testing.T) {
	t.Log("Testing WrapGoC with three parameter function: (a, b, c) -> a + b + c")

	// Three parameter add: ADD x0, x0, x1; ADD x0, x0, x2; RET
	bytecode := []byte{
		0x00, 0x00, 0x01, 0x8b, // add x0, x0, x1
		0x00, 0x00, 0x02, 0x8b, // add x0, x0, x2
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	var addThreeFunc func(int, int, int) int

	// Use WrapGoC to create the wrapper
	WrapGoC(bytecode, []CFunc{{
		Name:     "addThree",
		EntryOff: 0,
		TextSize: uint32(len(bytecode)),
		MaxStack: 0,
		Pcsp: [][2]uint32{
			{uint32(len(bytecode)), 0},
		},
	}}, []GoC{{
		CName:  "addThree",
		GoFunc: &addThreeFunc,
	}}, "test_add_three", "add_three.c")

	// Test the wrapped function
	result := addThreeFunc(10, 15, 17)
	expected := 42

	if result != expected {
		t.Errorf("Three parameter function failed: expected %d, got %d", expected, result)
	} else {
		t.Logf("✓ Three parameter function works: %d + %d + %d = %d", 10, 15, 17, result)
	}
}

// TestWrapC_SingleInt64 tests wrapper with only one int64 parameter
func TestWrapC_SingleInt64(t *testing.T) {
	// C function that increments an int64 by 1
	// int64_t increment(int64_t x) { return x + 1; }
	var increment func(x int64) int64

	// ARM64 assembly:
	// ADD X0, X0, #1    ; x0 = x0 + 1
	// RET               ; return
	ct := []byte{
		0x00, 0x04, 0x00, 0x91, // add x0, x0, #1
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "increment",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "increment",
		GoFunc: &increment,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	result := increment(42)
	require.Equal(t, int64(43), result)

	result = increment(-1)
	require.Equal(t, int64(0), result)

	result = increment(0)
	require.Equal(t, int64(1), result)
}

// TestWrapC_SingleFloat64 tests wrapper with only one float64 parameter
func TestWrapC_SingleFloat64(t *testing.T) {
	// C function that doubles a float64
	// double double_value(double x) { return x * 2.0; }
	var doubleValue func(x float64) float64

	// ARM64 assembly:
	// FADD D0, D0, D0   ; d0 = d0 + d0 (equivalent to d0 * 2)
	// RET
	ct := []byte{
		0x00, 0x28, 0x60, 0x1e, // fadd d0, d0, d0
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "double_value",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "double_value",
		GoFunc: &doubleValue,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	result := doubleValue(21.5)
	require.Equal(t, 43.0, result)

	result = doubleValue(0.0)
	require.Equal(t, 0.0, result)

	result = doubleValue(-10.5)
	require.Equal(t, -21.0, result)
}

// TestWrapC_TwoInt64 tests wrapper with two int64 parameters
func TestWrapC_TwoInt64(t *testing.T) {
	// C function that adds two int64s
	// int64_t add(int64_t a, int64_t b) { return a + b; }
	var add func(a, b int64) int64

	// ARM64 assembly:
	// ADD X0, X0, X1    ; x0 = x0 + x1
	// RET
	ct := []byte{
		0x00, 0x00, 0x01, 0x8b, // add x0, x0, x1
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "add",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "add",
		GoFunc: &add,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	result := add(10, 32)
	require.Equal(t, int64(42), result)

	result = add(-5, 5)
	require.Equal(t, int64(0), result)

	result = add(100, -50)
	require.Equal(t, int64(50), result)
}

// TestWrapC_SinglePointer tests wrapper with a single unsafe.Pointer parameter
func TestWrapC_SinglePointer(t *testing.T) {
	// C function that returns the pointer as int64 (just pass through)
	// int64_t ptr_value(void* ptr) { return (int64_t)ptr; }
	var ptrValue func(ptr unsafe.Pointer) int64

	// ARM64 assembly:
	// MOV X0, X0        ; nop, x0 already contains pointer
	// RET
	ct := []byte{
		0xe0, 0x03, 0x00, 0xaa, // mov x0, x0 (nop)
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "ptr_value",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "ptr_value",
		GoFunc: &ptrValue,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	var x int64 = 42
	runtime.SetFinalizer(&x, func(x *int64) {
		println("x got GC: ", x)
	})
	ptr := unsafe.Pointer(&x)
	result := ptrValue(ptr)
	expected := int64(uintptr(ptr))
	require.Equal(t, expected, result, "pointer value should match")
}

// TestWrapC_TwoPointers tests wrapper with two pointer parameters
func TestWrapC_TwoPointers(t *testing.T) {
	// C function that reads from first pointer and writes to second
	// void copy_value(int64_t* src, int64_t* dst) { *dst = *src; }
	// Returns first pointer value for testing
	var copyValue func(src, dst *int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; load *src into x8
	// STR X8, [X1]      ; store x8 to *dst
	// MOV X0, X8        ; return the copied value
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x28, 0x00, 0x00, 0xf9, // str x8, [x1]
		0xe0, 0x03, 0x08, 0xaa, // mov x0, x8
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "copy_value",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "copy_value",
		GoFunc: &copyValue,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	src := int64(100)
	runtime.SetFinalizer(&src, func(x *int64) {
		println("src got GC: ", x)
	})
	dst := int64(0)
	runtime.SetFinalizer(&dst, func(x *int64) {
		println("dst got GC: ", x)
	})
	result := copyValue(&src, &dst)
	require.Equal(t, int64(100), result, "return value should match src")
	require.Equal(t, int64(100), dst, "dst should be copied from src")

	src = int64(-999)
	dst = int64(123)
	result = copyValue(&src, &dst)
	require.Equal(t, int64(-999), result)
	require.Equal(t, int64(-999), dst)
}

// TestWrapC_ThreePointers tests wrapper with three pointer parameters
func TestWrapC_ThreePointers(t *testing.T) {
	// C function that adds values from two pointers and stores in third
	// int64_t add_ptrs(int64_t* a, int64_t* b, int64_t* result) {
	//   *result = *a + *b;
	//   return *result;
	// }
	var addPtrs func(a, b, result *int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *a
	// LDR X9, [X1]      ; x9 = *b
	// ADD X8, X8, X9    ; x8 = x8 + x9
	// STR X8, [X2]      ; *result = x8
	// MOV X0, X8        ; return x8
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x29, 0x00, 0x40, 0xf9, // ldr x9, [x1]
		0x08, 0x01, 0x09, 0x8b, // add x8, x8, x9
		0x48, 0x00, 0x00, 0xf9, // str x8, [x2]
		0xe0, 0x03, 0x08, 0xaa, // mov x0, x8
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "add_ptrs",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "add_ptrs",
		GoFunc: &addPtrs,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	a := int64(10)
	runtime.SetFinalizer(&a, func(x *int64) {
		println("a got GC: ", x)
	})
	b := int64(32)
	runtime.SetFinalizer(&b, func(x *int64) {
		println("b got GC: ", x)
	})
	result := int64(0)
	runtime.SetFinalizer(&result, func(x *int64) {
		println("result got GC: ", x)
	})
	ret := addPtrs(&a, &b, &result)
	require.Equal(t, int64(42), ret)
	require.Equal(t, int64(42), result)

	a = int64(-100)
	b = int64(50)
	result = int64(999)
	ret = addPtrs(&a, &b, &result)
	require.Equal(t, int64(-50), ret)
	require.Equal(t, int64(-50), result)
}

// TestWrapC_MixedPointerAndInt tests wrapper with mixed pointer and int parameters
func TestWrapC_MixedPointerAndInt(t *testing.T) {
	// C function that adds an int to a pointer value
	// int64_t add_offset(int64_t* ptr, int64_t offset) { return *ptr + offset; }
	var addOffset func(ptr *int64, offset int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *ptr
	// ADD X0, X8, X1    ; x0 = x8 + offset
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x00, 0x01, 0x01, 0x8b, // add x0, x8, x1
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "add_offset",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "add_offset",
		GoFunc: &addOffset,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	value := int64(40)
	runtime.SetFinalizer(&value, func(x *int64) {
		println("value got GC: ", x)
	})
	result := addOffset(&value, 2)
	require.Equal(t, int64(42), result)

	value = int64(100)
	result = addOffset(&value, -50)
	require.Equal(t, int64(50), result)
}

// TestWrapC_PointerSwap tests wrapper that swaps two pointer values
func TestWrapC_PointerSwap(t *testing.T) {
	// C function that swaps two int64 values via pointers
	// void swap(int64_t* a, int64_t* b) {
	//   int64_t temp = *a;
	//   *a = *b;
	//   *b = temp;
	// }
	// Returns *a for testing
	var swap func(a, b *int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *a (temp)
	// LDR X9, [X1]      ; x9 = *b
	// STR X9, [X0]      ; *a = x9
	// STR X8, [X1]      ; *b = x8
	// MOV X0, X9        ; return new value of *a
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x29, 0x00, 0x40, 0xf9, // ldr x9, [x1]
		0x09, 0x00, 0x00, 0xf9, // str x9, [x0]
		0x28, 0x00, 0x00, 0xf9, // str x8, [x1]
		0xe0, 0x03, 0x09, 0xaa, // mov x0, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "swap",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "swap",
		GoFunc: &swap,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	a := int64(10)
	runtime.SetFinalizer(&a, func(x *int64) {
		println("a got GC: ", x)
	})
	b := int64(20)
	runtime.SetFinalizer(&b, func(x *int64) {
		println("b got GC: ", x)
	})
	result := swap(&a, &b)
	require.Equal(t, int64(20), result, "return value should be new *a")
	require.Equal(t, int64(20), a, "a should now have b's original value")
	require.Equal(t, int64(10), b, "b should now have a's original value")

	a = int64(-100)
	b = int64(999)
	result = swap(&a, &b)
	require.Equal(t, int64(999), result)
	require.Equal(t, int64(999), a)
	require.Equal(t, int64(-100), b)
}

// TestWrapC_PointerChain tests wrapper with pointer chain operations
func TestWrapC_PointerChain(t *testing.T) {
	// C function that follows a pointer chain and increments
	// int64_t increment_deref(int64_t** pptr) { return ++(**pptr); }
	var incrementDeref func(pptr **int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *pptr (get inner pointer)
	// LDR X9, [X8]      ; x9 = **pptr (get value)
	// ADD X9, X9, #1    ; x9 = x9 + 1
	// STR X9, [X8]      ; **pptr = x9
	// MOV X0, X9        ; return x9
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x09, 0x01, 0x40, 0xf9, // ldr x9, [x8]
		0x29, 0x05, 0x00, 0x91, // add x9, x9, #1
		0x09, 0x01, 0x00, 0xf9, // str x9, [x8]
		0xe0, 0x03, 0x09, 0xaa, // mov x0, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "increment_deref",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "increment_deref",
		GoFunc: &incrementDeref,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	value := int64(41)
	runtime.SetFinalizer(&value, func(x *int64) {
		println("value got GC: ", x)
	})
	ptr := &value
	runtime.SetFinalizer(&ptr, func(x **int64) {
		println("ptr got GC: ", x)
	})
	pptr := &ptr
	runtime.SetFinalizer(&pptr, func(x ***int64) {
		println("pptr got GC: ", x)
	})
	result := incrementDeref(pptr)
	require.Equal(t, int64(42), result)
	require.Equal(t, int64(42), value, "original value should be incremented")
	require.Equal(t, int64(42), *ptr, "value via ptr should be incremented")
	require.Equal(t, int64(42), **pptr, "value via pptr should be incremented")
}

// TestWrapC_UnsafePointerArray tests wrapper with unsafe.Pointer to array
func TestWrapC_UnsafePointerArray(t *testing.T) {
	// C function that sums first 3 elements of an array
	// int64_t sum_array(int64_t* arr) { return arr[0] + arr[1] + arr[2]; }
	var sumArray func(arr unsafe.Pointer) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = arr[0]
	// LDR X9, [X0, #8]  ; x9 = arr[1]
	// ADD X8, X8, X9    ; x8 = x8 + x9
	// LDR X9, [X0, #16] ; x9 = arr[2]
	// ADD X0, X8, X9    ; x0 = x8 + x9
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x09, 0x04, 0x40, 0xf9, // ldr x9, [x0, #8]
		0x08, 0x01, 0x09, 0x8b, // add x8, x8, x9
		0x09, 0x08, 0x40, 0xf9, // ldr x9, [x0, #16]
		0x00, 0x01, 0x09, 0x8b, // add x0, x8, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "sum_array",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "sum_array",
		GoFunc: &sumArray,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	arr := [3]int64{10, 20, 12}
	runtime.SetFinalizer(&arr, func(x *[3]int64) {
		println("c got GC: ", x)
	})
	result := sumArray(unsafe.Pointer(&arr[0]))
	require.Equal(t, int64(42), result)

	arr = [3]int64{-100, 150, 0}
	result = sumArray(unsafe.Pointer(&arr[0]))
	require.Equal(t, int64(50), result)
}

// TestWrapC_TwoUnsafePointers tests wrapper with two unsafe.Pointer parameters
func TestWrapC_TwoUnsafePointers(t *testing.T) {
	// C function that copies from src to dst via unsafe pointers
	// void memcpy_int64(void* dst, void* src) { *(int64_t*)dst = *(int64_t*)src; }
	// Returns copied value
	var memcpyInt64 func(dst, src unsafe.Pointer) int64

	// ARM64 assembly:
	// LDR X8, [X1]      ; x8 = *(int64_t*)src
	// STR X8, [X0]      ; *(int64_t*)dst = x8
	// MOV X0, X8        ; return x8
	// RET
	ct := []byte{
		0x28, 0x00, 0x40, 0xf9, // ldr x8, [x1]
		0x08, 0x00, 0x00, 0xf9, // str x8, [x0]
		0xe0, 0x03, 0x08, 0xaa, // mov x0, x8
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "memcpy_int64",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "memcpy_int64",
		GoFunc: &memcpyInt64,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	src := int64(42)
	runtime.SetFinalizer(&src, func(x *int64) {
		println("src got GC: ", x)
	})
	dst := int64(0)
	runtime.SetFinalizer(&dst, func(x *int64) {
		println("dst got GC: ", x)
	})
	result := memcpyInt64(unsafe.Pointer(&dst), unsafe.Pointer(&src))
	require.Equal(t, int64(42), result)
	require.Equal(t, int64(42), dst)

	src = int64(-999)
	dst = int64(123)
	result = memcpyInt64(unsafe.Pointer(&dst), unsafe.Pointer(&src))
	require.Equal(t, int64(-999), result)
	require.Equal(t, int64(-999), dst)
}

// TestWrapC_UnsafePointerWithOffset tests unsafe.Pointer arithmetic
func TestWrapC_UnsafePointerWithOffset(t *testing.T) {
	// C function that reads from pointer with byte offset
	// int64_t read_offset(void* base, int64_t byte_offset) {
	//   return *(int64_t*)((char*)base + byte_offset);
	// }
	var readOffset func(base unsafe.Pointer, byteOffset int64) int64

	// ARM64 assembly:
	// ADD X8, X0, X1    ; x8 = base + byte_offset
	// LDR X0, [X8]      ; x0 = *(int64_t*)x8
	// RET
	ct := []byte{
		0x08, 0x00, 0x01, 0x8b, // add x8, x0, x1
		0x00, 0x01, 0x40, 0xf9, // ldr x0, [x8]
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "read_offset",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "read_offset",
		GoFunc: &readOffset,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	arr := [4]int64{10, 20, 30, 40}
	runtime.SetFinalizer(&arr, func(x *[4]int64) {
		println("arr got GC: ", x)
	})
	result := readOffset(unsafe.Pointer(&arr[0]), 0)
	require.Equal(t, int64(10), result)

	result = readOffset(unsafe.Pointer(&arr[0]), 8)
	require.Equal(t, int64(20), result)

	result = readOffset(unsafe.Pointer(&arr[0]), 16)
	require.Equal(t, int64(30), result)

	result = readOffset(unsafe.Pointer(&arr[0]), 24)
	require.Equal(t, int64(40), result)
}

// TestWrapC_ThreeUnsafePointers tests wrapper with three unsafe.Pointer parameters
func TestWrapC_ThreeUnsafePointers(t *testing.T) {
	// C function that performs operation on three memory locations
	// void triple_op(void* a, void* b, void* result) {
	//   *(int64_t*)result = *(int64_t*)a * *(int64_t*)b;
	// }
	// Returns the result value
	var tripleOp func(a, b, result unsafe.Pointer) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *(int64_t*)a
	// LDR X9, [X1]      ; x9 = *(int64_t*)b
	// MUL X8, X8, X9    ; x8 = x8 * x9
	// STR X8, [X2]      ; *(int64_t*)result = x8
	// MOV X0, X8        ; return x8
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x29, 0x00, 0x40, 0xf9, // ldr x9, [x1]
		0x08, 0x7d, 0x09, 0x9b, // mul x8, x8, x9
		0x48, 0x00, 0x00, 0xf9, // str x8, [x2]
		0xe0, 0x03, 0x08, 0xaa, // mov x0, x8
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "triple_op",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "triple_op",
		GoFunc: &tripleOp,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	a := int64(6)
	runtime.SetFinalizer(&a, func(x *int64) {
		println("a got GC: ", x)
	})
	b := int64(7)
	runtime.SetFinalizer(&b, func(x *int64) {
		println("b got GC: ", x)
	})
	result := int64(0)
	runtime.SetFinalizer(&result, func(x *int64) {
		println("result got GC: ", x)
	})
	ret := tripleOp(unsafe.Pointer(&a), unsafe.Pointer(&b), unsafe.Pointer(&result))
	require.Equal(t, int64(42), ret)
	require.Equal(t, int64(42), result)

	a = int64(-10)
	b = int64(5)
	result = int64(999)
	ret = tripleOp(unsafe.Pointer(&a), unsafe.Pointer(&b), unsafe.Pointer(&result))
	require.Equal(t, int64(-50), ret)
	require.Equal(t, int64(-50), result)
}

// TestWrapC_UnsafePointerStructAccess tests accessing struct fields via unsafe.Pointer
func TestWrapC_UnsafePointerStructAccess(t *testing.T) {
	// C function that reads two consecutive int64 fields (like a struct)
	// int64_t sum_struct(void* s) {
	//   return ((int64_t*)s)[0] + ((int64_t*)s)[1];
	// }
	var sumStruct func(s unsafe.Pointer) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = first field
	// LDR X9, [X0, #8]  ; x9 = second field
	// ADD X0, X8, X9    ; x0 = x8 + x9
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x09, 0x04, 0x40, 0xf9, // ldr x9, [x0, #8]
		0x00, 0x01, 0x09, 0x8b, // add x0, x8, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "sum_struct",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "sum_struct",
		GoFunc: &sumStruct,
	}}, "dummy/native", "dummy/native.c")

	// Test the function using a struct-like layout
	type TestStruct struct {
		A int64
		B int64
	}

	s := TestStruct{A: 20, B: 22}
	runtime.SetFinalizer(&s, func(x *TestStruct) {
		println("s got GC: ", x)
	})
	result := sumStruct(unsafe.Pointer(&s))
	require.Equal(t, int64(42), result)

	s = TestStruct{A: 100, B: -50}
	result = sumStruct(unsafe.Pointer(&s))
	require.Equal(t, int64(50), result)
}

// TestWrapC_MixedUnsafePointerAndTypedPointer tests mixing unsafe.Pointer and typed pointer
func TestWrapC_MixedUnsafePointerAndTypedPointer(t *testing.T) {
	// C function with both unsafe.Pointer and typed pointer
	// int64_t mixed_ptr(void* generic, int64_t* typed) {
	//   return *(int64_t*)generic + *typed;
	// }
	var mixedPtr func(generic unsafe.Pointer, typed *int64) int64

	// ARM64 assembly:
	// LDR X8, [X0]      ; x8 = *(int64_t*)generic
	// LDR X9, [X1]      ; x9 = *typed
	// ADD X0, X8, X9    ; x0 = x8 + x9
	// RET
	ct := []byte{
		0x08, 0x00, 0x40, 0xf9, // ldr x8, [x0]
		0x29, 0x00, 0x40, 0xf9, // ldr x9, [x1]
		0x00, 0x01, 0x09, 0x8b, // add x0, x8, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "mixed_ptr",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "mixed_ptr",
		GoFunc: &mixedPtr,
	}}, "dummy/native", "dummy/native.c")

	// Test the function
	a := int64(30)
	runtime.SetFinalizer(&a, func(x *int64) {
		println("a got GC: ", x)
	})
	b := int64(12)
	runtime.SetFinalizer(&b, func(x *int64) {
		println("b got GC: ", x)
	})
	result := mixedPtr(unsafe.Pointer(&a), &b)
	require.Equal(t, int64(42), result)

	a = int64(100)
	b = int64(-50)
	result = mixedPtr(unsafe.Pointer(&a), &b)
	require.Equal(t, int64(50), result)
}

// TestWrapC_UnsafePointerReturnOnly tests passing nil unsafe.Pointer (edge case)
func TestWrapC_UnsafePointerReturnOnly(t *testing.T) {
	// C function that just returns a constant, ignores pointer input
	// int64_t const_value(void* ignored) { return 42; }
	var constValue func(ignored unsafe.Pointer) int64

	// ARM64 assembly:
	// MOV X0, #42       ; x0 = 42
	// RET
	ct := []byte{
		0x40, 0x05, 0x80, 0xd2, // mov x0, #42
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "const_value",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "const_value",
		GoFunc: &constValue,
	}}, "dummy/native", "dummy/native.c")

	// Test the function with various pointers
	var x int64
	runtime.SetFinalizer(&x, func(x *int64) {
		println("x got GC: ", x)
	})
	result := constValue(unsafe.Pointer(&x))
	require.Equal(t, int64(42), result)

	// Test with nil pointer (function ignores it anyway)
	result = constValue(nil)
	require.Equal(t, int64(42), result)
}

// TestWrapC_UnsafePointerSliceData tests accessing slice underlying data
func TestWrapC_UnsafePointerSliceData(t *testing.T) {
	// C function that sums array elements via pointer
	// int64_t sum_n(void* arr, int64_t n) {
	//   int64_t sum = 0;
	//   for (int64_t i = 0; i < n; i++) {
	//     sum += ((int64_t*)arr)[i];
	//   }
	//   return sum;
	// }
	// Simplified for n=4
	var sumN func(arr unsafe.Pointer, n int64) int64

	// ARM64 assembly (hardcoded for 4 elements):
	// MOV X8, #0        ; sum = 0
	// LDR X9, [X0]      ; x9 = arr[0]
	// ADD X8, X8, X9    ; sum += x9
	// LDR X9, [X0, #8]  ; x9 = arr[1]
	// ADD X8, X8, X9    ; sum += x9
	// LDR X9, [X0, #16] ; x9 = arr[2]
	// ADD X8, X8, X9    ; sum += x9
	// LDR X9, [X0, #24] ; x9 = arr[3]
	// ADD X0, X8, X9    ; x0 = sum + x9
	// RET
	ct := []byte{
		0x08, 0x00, 0x80, 0xd2, // mov x8, #0
		0x09, 0x00, 0x40, 0xf9, // ldr x9, [x0]
		0x08, 0x01, 0x09, 0x8b, // add x8, x8, x9
		0x09, 0x04, 0x40, 0xf9, // ldr x9, [x0, #8]
		0x08, 0x01, 0x09, 0x8b, // add x8, x8, x9
		0x09, 0x08, 0x40, 0xf9, // ldr x9, [x0, #16]
		0x08, 0x01, 0x09, 0x8b, // add x8, x8, x9
		0x09, 0x0c, 0x40, 0xf9, // ldr x9, [x0, #24]
		0x00, 0x01, 0x09, 0x8b, // add x0, x8, x9
		0xc0, 0x03, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "sum_n",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "sum_n",
		GoFunc: &sumN,
	}}, "dummy/native", "dummy/native.c")

	// Test with slice
	slice := []int64{5, 10, 15, 12}
	result := sumN(unsafe.Pointer(&slice[0]), 4)
	require.Equal(t, int64(42), result)

	slice = []int64{100, -20, -30, 0}
	result = sumN(unsafe.Pointer(&slice[0]), 4)
	require.Equal(t, int64(50), result)
}

func TestWrapC_ReturnZero(t *testing.T) {
	// asm function that clear all caller-save reg as 0
	// accept no args
	// then return 0
	var return_zero func(input int64) int64

	ct := []byte{
		0xfd, 0x7b, 0xbf, 0xa9, // stp x29, x30, [sp, #-0x10]!
		0xe0, 0x3, 0x1f, 0xaa, // mov x0, xzr
		0xf0, 0x3, 0x0, 0xaa, // mov x16, x0
		0xf1, 0x3, 0x0, 0xaa, // mov x17, x0
		0xe1, 0x3, 0x1f, 0xaa, // mov x1, xzr
		0xe2, 0x3, 0x1f, 0xaa, // mov x2, xzr
		0xe3, 0x3, 0x1f, 0xaa, // mov x3, xzr
		0xe4, 0x3, 0x1f, 0xaa, // mov x4, xzr
		0xe5, 0x3, 0x1f, 0xaa, // mov x5, xzr
		0xe6, 0x3, 0x1f, 0xaa, // mov x6, xzr
		0xe7, 0x3, 0x1f, 0xaa, // mov x7, xzr
		0xe8, 0x3, 0x1f, 0xaa, // mov x8, xzr
		0xe9, 0x3, 0x1f, 0xaa, // mov x9, xzr
		0xea, 0x3, 0x1f, 0xaa, // mov x10, xzr
		0xeb, 0x3, 0x1f, 0xaa, // mov x11, xzr
		0xec, 0x3, 0x1f, 0xaa, // mov x12, xzr
		0xed, 0x3, 0x1f, 0xaa, // mov x13, xzr
		0xee, 0x3, 0x1f, 0xaa, // mov x14, xzr
		0xef, 0x3, 0x1f, 0xaa, // mov x15, xzr
		0xfd, 0x7b, 0xc1, 0xa8, // ldp x29, x30, [sp], #0x10
		0xc0, 0x3, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "return_zero",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(16),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 16},
		},
	}}, []GoC{{
		CName:  "return_zero",
		GoFunc: &return_zero,
	}}, "dummy/native", "dummy/native.c")

	// Test with literal
	result := return_zero(4)
	require.Equal(t, int64(0), result)

	result = return_zero(-17)
	require.Equal(t, int64(0), result)
}

func TestWrapC_ReturnOne(t *testing.T) {
	// asm function that clear all caller-save reg as 0
	// accept no args
	// then return 1
	var return_one func(input int64) int64

	ct := []byte{
		0x20, 0x0, 0x80, 0xd2, // mov x0, #0x1
		0x41, 0x15, 0x80, 0xd2, // mov x1, #0xaa
		0xe2, 0x3, 0x1, 0xaa, // mov x2, x1
		0xe3, 0x3, 0x1, 0xaa, // mov x3, x1
		0xe4, 0x3, 0x1, 0xaa, // mov x4, x1
		0xe5, 0x3, 0x1, 0xaa, // mov x5, x1
		0xe6, 0x3, 0x1, 0xaa, // mov x6, x1
		0xe7, 0x3, 0x1, 0xaa, // mov x7, x1
		0xe8, 0x3, 0x1, 0xaa, // mov x8, x1
		0xe9, 0x3, 0x1, 0xaa, // mov x9, x1
		0xea, 0x3, 0x1, 0xaa, // mov x10, x1
		0xeb, 0x3, 0x1, 0xaa, // mov x11, x1
		0xec, 0x3, 0x1, 0xaa, // mov x12, x1
		0xed, 0x3, 0x1, 0xaa, // mov x13, x1
		0xee, 0x3, 0x1, 0xaa, // mov x14, x1
		0xef, 0x3, 0x1, 0xaa, // mov x15, x1
		0xf0, 0x3, 0x1, 0xaa, // mov x16, x1
		0xf1, 0x3, 0x1, 0xaa, // mov x17, x1
		0xc0, 0x3, 0x5f, 0xd6, // ret
	}

	WrapGoC(ct, []CFunc{{
		Name:     "return_one",
		EntryOff: 0,
		TextSize: uint32(len(ct)),
		MaxStack: uintptr(0x20),
		Pcsp: [][2]uint32{
			{uint32(len(ct)), 0},
		},
	}}, []GoC{{
		CName:  "return_one",
		GoFunc: &return_one,
	}}, "dummy/native", "dummy/native.c")

	{
		// Test with literal
		result := return_one(4)
		require.Equal(t, int64(1), result)

		result = return_one(-17)
		require.Equal(t, int64(1), result)
	}
}
