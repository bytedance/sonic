//go:build arm64
// +build arm64

// Code generated by scripts, DO NOT EDIT.

/*
 * Copyright 2025 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sve_linkname

import (
	"strings"
	"testing"

	"github.com/bytedance/sonic/internal/native/types"
	"github.com/stretchr/testify/assert"
)

func TestNative_SkipOne(t *testing.T) {
	p := 0
	s := ` {"asdf": [null, true, false, 1, 2.0, -3]}, 1234.5`
	q := skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 42, p)
	assert.Equal(t, 1, q)
	p = 0
	s = `1 2.5 -3 "asdf\nqwer" true false null {} []`
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 1, p)
	assert.Equal(t, 0, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 5, p)
	assert.Equal(t, 2, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 8, p)
	assert.Equal(t, 6, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 21, p)
	assert.Equal(t, 9, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 26, p)
	assert.Equal(t, 22, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 32, p)
	assert.Equal(t, 27, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 37, p)
	assert.Equal(t, 33, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 40, p)
	assert.Equal(t, 38, q)
	q = skip_one(&s, &p, &types.StateMachine{}, uint64(0))
	assert.Equal(t, 43, p)
	assert.Equal(t, 41, q)
}

func TestNative_SkipOne_Error(t *testing.T) {
	for _, s := range []string{
		"-", "+", "0.", "0. ", "+1", "0.0e ", "9e+", "0e-",
		"tru", "fals", "nul", "trux", "fals ",
		`"asdf`, `"\\\"`,
	} {
		p := 0
		q := skip_one(&s, &p, &types.StateMachine{}, uint64(0))
		assert.True(t, q < 0)
	}
}

func TestNative_SkipOneFast(t *testing.T) {
	p := 0
	s := ` {"asdf": [null, true, false, 1, 2.0, -3]}, 1234.5`
	q := skip_one_fast(&s, &p)
	assert.Equal(t, 42, p)
	assert.Equal(t, 1, q)
	p = 0
	s = `1, 2.5, -3, "asdf\nqwer", true, false, null, {}, [],`
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 1, p)
	assert.Equal(t, 0, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 6, p)
	assert.Equal(t, 3, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 10, p)
	assert.Equal(t, 8, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 24, p)
	assert.Equal(t, 12, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 30, p)
	assert.Equal(t, 26, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 37, p)
	assert.Equal(t, 32, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 43, p)
	assert.Equal(t, 39, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 47, p)
	assert.Equal(t, 45, q)
	p += 1
	q = skip_one_fast(&s, &p)
	assert.Equal(t, 51, p)
	assert.Equal(t, 49, q)
}

func TestNative_SkipOneFast_Error(t *testing.T) {
	for _, s := range []string{
		"{{", "[{", "{{}",
		`"asdf`, `"\\\"`,
	} {
		p := 0
		q := skip_one_fast(&s, &p)
		assert.True(t, q < 0)
	}
}

func TestNative_GetByPath(t *testing.T) {
	s := `{"asdf": [null, true, false, 1, 2.0, -3]}, 1234.5`
	p := 0
	path := []interface{}{"asdf", 4}
	ret := get_by_path(&s, &p, &path, types.NewStateMachine())
	assert.Equal(t, strings.Index(s, "2.0"), ret)
}

func BenchmarkNative_SkipOneFast(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		s := `{"asdf": [null, true, false, 1, 2.0, -3]}, 1234.5`
		p := 0
		_ = skip_one_fast(&s, &p)
	}
}

func BenchmarkNative_GetByPath(b *testing.B) {
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		s := `{"asdf": [null, true, false, 1, 2.0, -3]}, 1234.5`
		p := 0
		path := []interface{}{"asdf", 3}
		sm := types.NewStateMachine()
		_ = get_by_path(&s, &p, &path, sm)
		types.FreeStateMachine(sm)
	}
}
