// Code generated by scripts, DO NOT EDIT.

/**
 * Copyright 2023 ByteDance Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sve_linkname

import (
	"bytes"
	"os"
	"runtime"
	"runtime/debug"
	"testing"
	"time"
	"unsafe"
	"bufio"
	"strings"
	"github.com/shirou/gopsutil/cpu"
	"github.com/bytedance/sonic/internal/native/types"
)

func CpuDetect() bool {
	cpuinfo, err := cpu.Info()
	if err != nil {
		return false
	}

	if cpuinfo[0].Model == "0xd02" || cpuinfo[0].Model == "0xd06" {
		return true
	}

    file, err := os.Open("/proc/cpuinfo")
	if err != nil {
		return false
	}
	defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
    	line := scanner.Text()
    	if strings.HasPrefix(line, "CPU part") {
    		parts := strings.SplitN(line, ":", 2)
			model := strings.TrimSpace(parts[1])
		if model == "0xd02" || model == "0xd06" {
				return true
			}
    	}
    }
	return false
}

var (
	debugAsyncGC = os.Getenv("SONIC_NO_ASYNC_GC") == ""
)

func TestMain(m *testing.M) {
	if CpuDetect() != true {
		println("skip sve_wrapgoc test")
		return
	}
	go func() {
		if !debugAsyncGC {
			return
		}
		println("Begin GC looping...")
		for {
			runtime.GC()
			debug.FreeOSMemory()
		}
		println("stop GC looping!")
	}()
	time.Sleep(time.Millisecond * 100)
	m.Run()
}

func TestRecover_html_escape(t *testing.T) {
	var dn = 10
	var dp = make([]byte, dn)
	var sp = []byte("123")
	t.Run("sp", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = html_escape(nil, 3, unsafe.Pointer(&dp[0]), &dn)
	})
	t.Run("dp", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = html_escape(unsafe.Pointer(&sp[0]), 3, nil, &dn)
	})
	t.Run("dn", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = html_escape(unsafe.Pointer(&sp[0]), 3, unsafe.Pointer(&dp[0]), nil)
	})
}

func TestRecover_skip_one(t *testing.T) {
	var v = types.NewStateMachine()
	var sp = "123"
	var p = 0
	t.Run("sp", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = skip_one(nil, &p, v, 0)
	})
	t.Run("p", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = skip_one(&sp, nil, v, 0)
	})
	t.Run("v", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = skip_one(&sp, &p, nil, 0)
	})
}

func TestRecover_skip_one_fast(t *testing.T) {
	var sp = "123"
	var p = 0
	t.Run("sp", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = skip_one_fast(nil, &p)
	})
	t.Run("p", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = skip_one_fast(&sp, nil)
	})
}

func TestRecover_get_by_path(t *testing.T) {
	var v = []interface{}{}
	var sp = "123"
	var p = 0
	var m = types.NewStateMachine()
	t.Run("sp", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = get_by_path(nil, &p, &v, m)
	})
	t.Run("p", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = get_by_path(&sp, nil, &v, m)
	})
	t.Run("path", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		_ = get_by_path(&sp, &p, nil, m)
	})
}

func TestRecover_parse_with_padding(t *testing.T) {
	defer func() {
		if r := recover(); r!= nil {
			t.Log("recover: ", r)
		} else {
			t.Fatal("no panic")
		}
	}()
	_ = parse_with_padding(nil)
}

func TestRecover_lookup_small_key(t *testing.T) {
	t.Run("key", func(t *testing.T) {
		defer func() {
			if r := recover(); r!= nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		b := bytes.Repeat([]byte("a"), 100)
		_ = lookup_small_key(nil, &b, 10)
	})
	t.Run("table", func(t *testing.T) {
		defer func() {
			if r := recover(); r!= nil {
				t.Log("recover: ", r)
			} else {
				t.Fatal("no panic")
			}
		}()
		key := "a"
		_ = lookup_small_key(&key, nil, 10)
	})
}